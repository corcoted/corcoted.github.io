<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-08-02">

<title>Optics in Homogeneous Coordinates, Imaging Points</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="2023-08-02-HomogeneousOptics-3_files/libs/clipboard/clipboard.min.js"></script>
<script src="2023-08-02-HomogeneousOptics-3_files/libs/quarto-html/quarto.js"></script>
<script src="2023-08-02-HomogeneousOptics-3_files/libs/quarto-html/popper.min.js"></script>
<script src="2023-08-02-HomogeneousOptics-3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2023-08-02-HomogeneousOptics-3_files/libs/quarto-html/anchor.min.js"></script>
<link href="2023-08-02-HomogeneousOptics-3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2023-08-02-HomogeneousOptics-3_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2023-08-02-HomogeneousOptics-3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2023-08-02-HomogeneousOptics-3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2023-08-02-HomogeneousOptics-3_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Optics in Homogeneous Coordinates, Imaging Points</h1>
  <div class="quarto-categories">
    <div class="quarto-category">research</div>
    <div class="quarto-category">optics</div>
    <div class="quarto-category">papers</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 2, 2023</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="abstract-title">Abstract</div>
    Our new 3&nbsp;3 ray matrices give us shortcuts to finding images.
  </div>
</div>

</header>

<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>This is the third post discussing my recent paper on a new way to look at geometric optics. I deconstruct the familiar ABCD ray-transfer matrices and rebuild them based on geometric considerations. The paper itself is published in <em>American Journal of Physics</em><span class="citation" data-cites="corcovilos2023">(<a href="#ref-corcovilos2023" role="doc-biblioref">Corcovilos 2023</a>)</span>. These blog posts will focus on the motivation and how to use the results.</p>
</div>
</div>
</div>
<ul>
<li><a href="/posts/2022-05-20-HomogeneousOptics-1.qmd">Part 1</a></li>
<li><a href="/posts/2022-07-01-HomogeneousOptics-2.qmd">Part 2</a></li>
</ul>
<section id="picking-up-from-last-time" class="level2">
<h2 class="anchored" data-anchor-id="picking-up-from-last-time">Picking up from last time…</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="/assets/figs/2022-optics/line.svg" class="img-fluid figure-img" data-alt-text="Graph of a line"></p>
<figcaption class="figure-caption">The equation of an oriented line. In this example, <em>a</em> and <em>b</em> &gt; 0 and <em>c</em>&lt;0.</figcaption>
</figure>
</div>
<p>In the <a href="/posts/2022-05-20-HomogeneousOptics-1.qmd">first post</a> I defined an oriented line by considering the equation of a line in 2D: <span class="math inline">\(ax+by+c = 0\)</span>. This gave us new 3×3 matrices for describing our optical system that contain the traditional <em>ABCD</em> matrices as a subset, with these new matrices acting on ray vectors of the form <span class="math inline">\((c,a,b)\)</span>. (I had to shuffle the order to match the old-school ABCD matrices.)</p>
<p><span class="math display">\[
\begin{pmatrix} c' \\\ a' \\\ b' \end{pmatrix}
=
\begin{pmatrix} A &amp; B &amp; 0
\\\ C &amp; D &amp; 0
\\\ 0 &amp; 0 &amp; 1 \end{pmatrix}
\begin{pmatrix} c \\\ a \\\ b \end{pmatrix}.
\]</span></p>
<p>The <a href="/posts/2022-07-01-HomogeneousOptics-2.qmd">second post</a> showed that the extra degrees of freedom gained by upgrading to 3×3 (the third row and column in the matrix above) also let us move and rotate our optical elements: we’re no longer confined to being centered on and normal to a single optical axis.</p>
<p>In this post, I show a little slight of hand using projective geometry<span class="citation" data-cites="coexter stolfi">(<a href="#ref-coexter" role="doc-biblioref"><strong>coexter?</strong></a>; <a href="#ref-stolfi" role="doc-biblioref">Stolfi 2014</a>)</span> that lets us reframe our matrices as transformations of <em>points</em> rather than rays. In other words, we can do imaging calculations directly from the matrices without going through the usual process of tracing rays.</p>
</section>
<section id="homegenous-representation-of-points" class="level2">
<h2 class="anchored" data-anchor-id="homegenous-representation-of-points">Homegenous representation of points</h2>
<p>We began this whole discussion by writing our equation for a line as <span class="math inline">\(ax+by+c = 0\)</span>, giving us three homogenous coefficients describing the line: <span class="math inline">\(\vec{r}=(c,a,b)\)</span>. The line is the set of points <span class="math inline">\([x,y]\)</span> that solve the equation. (I’ll use square brackets for points and round brackets for lines). It would be nice to have a 3rd coefficient for our points, as well, so let’s just add one: <span class="math inline">\(\vec{p}=[w,x,y]\)</span>, where up until now we’ve always had <span class="math inline">\(w=1\)</span>. With these two setups for lines and points, we can re-express the line equation as a simple vector equation:</p>
<p><span class="math display">\[
ax+by+cw=0\quad\rightarrow\vec{r}\cdot\vec{p}=0
\]</span></p>
<section id="normalization-of-points" class="level3">
<h3 class="anchored" data-anchor-id="normalization-of-points">Normalization of points</h3>
<p>We can muliply our point vector with any non-zero scalar and still satisfy the line equation, so this <span class="math inline">\([w,x,y]\)</span> is indeed a homogeneous representation of a point. Our most typical case is when <span class="math inline">\(w=1\)</span>, so we’ll pick this as our normalization convention for points. In other words, if <span class="math inline">\(w\neq1\)</span>, divide by <span class="math inline">\(w\)</span> to get the “real” values (physical locations) of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
</section>
<section id="ideal-points" class="level3">
<h3 class="anchored" data-anchor-id="ideal-points">Ideal points</h3>
<p>What happens if we let <em>w</em> go to zero? Think of this in the limit as we gradually reduce the value of <em>w</em> while <em>x</em> and <em>y</em> are fixed. The new normalized point would be <span class="math inline">\([1,{x}/{w},{y}/{w}]\)</span>, which would move further and further away from the origin. See the figure below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="/assets/figs/2022-optics/h-points.svg" class="img-fluid figure-img" data-alt-text="Plot of homogeneous points with different w values"></p>
<figcaption class="figure-caption">Changing the <em>w</em> value of a homogeneous point</figcaption>
</figure>
</div>
<p>In the limit <span class="math inline">\(w\rightarrow 0\)</span>, the point does off to infinity in a particular direction. We can think of <span class="math inline">\([0,x,y]\)</span> either as that direction and not a physical point or as a physical point effectively infinitely far away (e.g.&nbsp;a distant star being viewed by a telescope).</p>
</section>
</section>
<section id="projective-duality" class="level2">
<h2 class="anchored" data-anchor-id="projective-duality">Projective duality</h2>
<p>Now that we have defined points and lines on equal algebraic footing, let’s go back and look at the line equation:</p>
<p><span class="math display">\[
ax+by+cw=0.
\]</span></p>
<p>Our habit is to interpret this as the points <span class="math inline">\([w,x,y]\)</span> that lie on the (fixed) line <span class="math inline">\((c,a,b)\)</span>, but the <em>dual</em> interpretation is also valid: the equation represents all of the lines <span class="math inline">\((c,a,b)\)</span> that pass through the (fixed) point <span class="math inline">\([w,x,y]\)</span> (see figure below).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="/assets/figs/2022-optics/bundle.svg" class="img-fluid figure-img" data-alt-text="Lines going through a point"></p>
<figcaption class="figure-caption">Interpreting the equation <em>ax</em>+<em>by</em>+<em>cw</em>=0 as a bundle of lines going through the homogeneous point [<em>w</em>,<em>x</em>,<em>y</em>].</figcaption>
</figure>
</div>
<p>If we take this idea and extrapolate as far as possible, we get the <a href="https://en.wikipedia.org/wiki/Duality_(projective_geometry)">Principle of Projective Duality</a>. The two-dimesional version of this says that any relationship between lines implies a corresponding relationship between points (and vice versa). Importantly for us, if our 3×3 ray matrices provide a rule for transforming rays (lines) from the object space to the image space of our optical system, then duality tells us that a similar rule must apply to points.</p>
<p>Great! But what’s the rule for points?</p>
</section>
<section id="the-point-transfer-matrices" class="level2">
<h2 class="anchored" data-anchor-id="the-point-transfer-matrices">The point transfer matrices</h2>
<p>Let’s go back to our line equation. I’ll use the vector form to save some writing:</p>
<p><span class="math display">\[
\vec{p}\cdot\vec{r}=0.
\]</span></p>
<p>If we have an intersecting ray and point described by the equation above, if we project those through our optical system their images should still intersect. The image of the point will not become disconnected from the image of the ray. If I use primes to indicate the images, mathematically we should have</p>
<p><span class="math display">\[
\vec{p'}\cdot\vec{r'}=0.
\]</span></p>
<p>We know what the new ray vector image is because we know the matrix for the optical system, <em>M</em>. That gives us</p>
<p><span class="math display">\[
\vec{r'} = M\vec{r}.
\]</span></p>
<p>We’d like a similar rule for points. It should also be a linear function, so it should be a new matrix, which I’ll represent by <span class="math inline">\(M_p\)</span> and call the <em>point transfer matrix</em> (PTM). (In the paper I use overbar-<em>M</em>, but that isn’t displaying correctly here.) That rule will be</p>
<p><span class="math display">\[
\vec{p'} = M_p \vec{p},
\]</span></p>
<p>but we don’t know <span class="math inline">\(M_p\)</span> yet. Let’s stick with it anyway and plug the image of the ray and the image of the point into the incidence equation:</p>
<p><span class="math display">\[
\vec{p'}\cdot\vec{r'}=0\quad\rightarrow\quad
(M_p\vec{p})\cdot(M\vec{r}) = 0.
\]</span> Evaluating the dot product as a row vector times a column vector by using a transpose operation (<sup>T</sup>), and then rearranging we get</p>
<p><span class="math display">\[
\begin{gathered}
(M_p\vec{p})^T(M\vec{r}) = 0, \\
\vec{p}^T M_p^T M \vec{r} = 0.
\end{gathered}
\]</span> This equation can only be true if either <span class="math inline">\(M_p^TM=0\)</span> (which would be boring) or if <span class="math inline">\(M_p^TM\)</span> is proportional to the identity matrix:</p>
<p><span class="math display">\[
\begin{gathered}
M_p^TM = k I, \\
M_p = k (M^{-1})^T,
\end{gathered}
\]</span> where <em>k</em> is some non-zero constant. Because we’re using homogenous representations for our point, the value of <em>k</em> doesn’t matter, but if we’re being picky we can show from other arguments that its actual value is the determinant of <em>M</em>.</p>
<p>In particular, if we know the <em>ABCD</em> matrix, the corresponding point transfer matrix is</p>
<p><span class="math display">\[
M_p = \begin{bmatrix}
D &amp; -C &amp; 0 \\
-B &amp; A &amp; 0 \\
0 &amp; 0 &amp; AD-BC
\end{bmatrix}
\]</span></p>
<p>For the tilted and decenterd examples in <a href="/posts/2022-07-01-HomogeneousOptics-2.qmd">Part 2</a> the PTMs are a bit uglier, but the same algebra rules apply.</p>
</section>
<section id="example-calculation" class="level2">
<h2 class="anchored" data-anchor-id="example-calculation">Example calculation</h2>
<p>In the paper<span class="citation" data-cites="corcovilos2023">(<a href="#ref-corcovilos2023" role="doc-biblioref">Corcovilos 2023</a>)</span> I use the PTMs to derive Gauss’s thin lens equation and do a few more examples, but my favorite aspect of this method is that we can find images (and their magnifications) <em>without explicitly tracing rays</em>.</p>
<p>As an example, we’ll take a problem from Hecht<span class="citation" data-cites="hecht">(<a href="#ref-hecht" role="doc-biblioref">Hecht 2017</a>)</span> (note that we use a different convention for the ray transfer matrices than Hecht). Consider a compound lens system with the ray transfer matrix (length units of cm)</p>
<p><span class="math display">\[
M=\begin{pmatrix} A &amp; B \\ C &amp; D \end{pmatrix}
=
\begin{pmatrix}
    0.867 &amp; 1.338 \\ -0.198 &amp; 0.848
  \end{pmatrix},
\]</span></p>
<p>and an object 20 cm in front of the lens with a height of 0.1 cm. We would like to locate the resulting image position and height.</p>
<p>Hecht’s solution has several steps: (1) Extend the system matrix <span class="math inline">\(M\)</span> with a propagation matrix of length 20 cm in front of the lens (for the object position) and a propagation of unknown length <span class="math inline">\(d\)</span> after the lens (for the image position) so that the system matrix now includes both the object and image points. (2) Algebraically set the <span class="math inline">\(B\)</span> element of the resulting product matrix to zero. This enforces the condition that the final ray height is independent of the incoming ray slope (i.e.&nbsp;an image forms). With this constraint, one can solve for the unknown length <span class="math inline">\(d\)</span> to locate the image plane. (3) Identify the magnification as the <span class="math inline">\(A\)</span> element of the resulting matrix. This is true because we set <span class="math inline">\(B=0\)</span> above, meaning that the image ray height only depends on the object ray height, which gives us the magnification.</p>
<p>Our solution is much more direct. First, we construct the point transfer matrix from the original ray transfer matrix (without additional propagations) and multiply this into the homogeneous position vector <span class="math inline">\(p=[1,x,y]^T\)</span> for the object point. This gives us the image point <span class="math inline">\(p'\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
  p'=
    {M}_p p &amp;=
    {\small
      \begin{bmatrix}
        0.848 &amp; 0.198 &amp; 0 \\
        -1.338 &amp; 0.867 &amp; 0 \\
        0 &amp; 0 &amp; 1
      \end{bmatrix}
      \begin{bmatrix}
        1 \\ -20.0 \\ 0.1
      \end{bmatrix}},\\
      &amp;= {\small
      \begin{bmatrix}
        -3.112 \\ -18.678 \\ 0.1
      \end{bmatrix}}
      \equiv {\small
      \begin{bmatrix}
        1 \\ 6.002 \\ -0.032
      \end{bmatrix}}.
    \end{aligned}
\]</span></p>
<p>After performing the matrix multiplication, we only need to normalize the resulting image point vector (final step above) to read off the coordinates of the image: <span class="math inline">\({6.002}\,\mathrm{cm}\)</span> past the lens at a height of <span class="math inline">\({-0.032}\,\mathrm{cm}\)</span>. We’ve been able to replace algebraic multiplication of matrices containing unknown variables and solving for an unknown distance with a direct numerical calculation, rather than going through Hecht’s process that requires setting up and solving some algebra equations.</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>Using some ideas from projective geometry[^3], we defined points using homogeneous coordinates and showed that the points have their own matrix representation for an optical system.</p>
<p>Why do we care? First, it gives us a shortcut for solving some imaging problems, especially if we already know the ray transfer matrix. I’ll work another extended example in the next post using the PTMs to find the entrance and exit pupils of a lens system. But more broadly, this shows that projective geometry<span class="citation" data-cites="stolfi">(<a href="#ref-stolfi" role="doc-biblioref">Stolfi 2014</a>)</span> is really the right environment for optics work. Some other tricks with homogenous points and lines vastly simplify things like calculating the circle of confusion for defocussed lenses, depth of field, and other things that usually result in a big algebra mess.</p>
<p>But wait, can’t the computer do all of this faster and better? Sure. We’re not doing full ray trancing or wave-front analysis here. We can’t see aberations or diffraction or things like that. The point is to put the <em>geometry</em> (well, geometry disguised as algebra) back into <em>geometric optics</em>.</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-corcovilos2023" class="csl-entry" role="listitem">
Corcovilos, Theodore A. 2023. <span>“Beyond the ABCDs: A Better Matrix Method for Geometric Optics by Using Homogeneous Coordinates.”</span> <em>American Journal of Physics</em>. <a href="https://arxiv.org/abs/2205.09746">arXiv:2205.09746</a>. <a href="https://doi.org/10.1119/5.0083069">https://doi.org/10.1119/5.0083069</a>.
</div>
<div id="ref-hecht" class="csl-entry" role="listitem">
Hecht, Eugene. 2017. <em>Optics</em>. 5th ed. Boston: Pearson.
</div>
<div id="ref-stolfi" class="csl-entry" role="listitem">
Stolfi, Jorge. 2014. <em>Oriented Projective Geometry: A Framework for Geometric Computations</em>. Academic.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>